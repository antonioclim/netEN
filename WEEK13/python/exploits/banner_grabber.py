#!/usr/bin/env python3
"""Week 13 - Banner grabber (service enumeration, educational).

This script performs *light-weight* service enumeration by:
- connecting to a TCP port
- reading the initial banner (when present)
- optionally sending a minimal HTTP request for HTTP services

It is intended for defensive learning (fingerprinting and exposure analysis).
It does NOT exploit vulnerabilities.

Examples
--------
Single port:
  python3 python/exploits/banner_grabber.py --target 127.0.0.1 --port 2121

Multiple ports:
  python3 python/exploits/banner_grabber.py --target 127.0.0.1 --ports 21,80,1883,8883,2121

HTTP probe:
  python3 python/exploits/banner_grabber.py --target 127.0.0.1 --port 8080 --http
"""

from __future__ import annotations

import argparse
import json
import socket
import sys
from dataclasses import asdict, dataclass
from datetime import datetime
from typing import List, Optional


@dataclass
class BannerResult:
    target: str
    port: int
    success: bool
    banner: Optional[str] = None
    error: Optional[str] = None


def parse_ports(spec: str) -> List[int]:
    ports: List[int] = []
    for part in spec.split(","):
        part = part.strip()
        if not part:
            continue
        if "-" in part:
            a, b = part.split("-", 1)
            ports.extend(range(int(a), int(b) + 1))
        else:
            ports.append(int(part))
    # de-duplicate, stable order
    seen = set()
    out: List[int] = []
    for p in ports:
        if p not in seen:
            seen.add(p)
            out.append(p)
    return out


def grab_banner(host: str, port: int, timeout: float = 2.0, http: bool = False) -> BannerResult:
    try:
        with socket.create_connection((host, port), timeout=timeout) as s:
            s.settimeout(timeout)
            if http:
                req = (
                    f"GET / HTTP/1.0\r\n"
                    f"Host: {host}\r\n"
                    f"User-Agent: week13-banner-grabber\r\n"
                    f"Connection: close\r\n\r\n"
                ).encode()
                s.sendall(req)

            data = b""
            while len(data) < 4096:
                chunk = s.recv(1024)
                if not chunk:
                    break
                data += chunk
                if b"\n" in data:
                    break

        banner = data.decode(errors="replace").strip() or None
        return BannerResult(target=host, port=port, success=True, banner=banner)
    except Exception as exc:
        return BannerResult(target=host, port=port, success=False, error=str(exc))


def main() -> int:
    parser = argparse.ArgumentParser(description="Week 13 - Banner grabber (educational)")
    parser.add_argument("--target", required=True, help="Target host, eg 127.0.0.1")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--port", type=int, help="Single TCP port")
    group.add_argument("--ports", help="Comma-separated ports and ranges, e.g. 21,80,1883-1884")
    parser.add_argument("--timeout", type=float, default=2.0, help="Socket timeout in seconds (default: 2.0)")
    parser.add_argument("--http", action="store_true", help="Send a minimal HTTP request (useful for web services)")
    parser.add_argument("--json-out", default=None, help="Optional JSON output path")
    args = parser.parse_args()

    ports = [args.port] if args.port is not None else parse_ports(args.ports)

    results = [grab_banner(args.target, p, timeout=args.timeout, http=args.http) for p in ports]

    print("=" * 72)
    print("Week 13 - Banner grabber (educational)")
    print("=" * 72)
    print(f"Target: {args.target}")
    print(f"Ports: {', '.join(str(p) for p in ports)}")
    print(f"HTTP probe: {args.http}")
    print(f"Timeout: {args.timeout}s")
    print()

    for r in results:
        if r.success:
            b = r.banner if r.banner else "(no banner)"
            print(f"[{r.port}] OK  {b}")
        else:
            print(f"[{r.port}] ERR {r.error}")

    if args.json_out:
        payload = {
            "timestamp_utc": datetime.utcnow().isoformat(timespec="seconds") + "Z",
            "results": [asdict(r) for r in results],
        }
        with open(args.json_out, "w", encoding="utf-8") as fp:
            json.dump(payload, fp, indent=2)
        print(f"\nJSON written to: {args.json_out}")

    # Exit 0 if at least one succeeded, else 1
    return 0 if any(r.success for r in results) else 1


if __name__ == "__main__":
    sys.exit(main())
