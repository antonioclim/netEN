#!/usr/bin/env python3
"""
================================================================================
Banner Grabber - Service enumeration through analiza banner-urilor
================================================================================
S13 - IoT and Security in Computer Networks

PEDAGOGICAL OBJECTIVES:
1. Understanding procesului of fingerprinting al serviceslor
2. Information extraction from protocol responses
3. Identificationa versiunilor software for assessmenta securitatii

USAGE:
    python3 banner_grabber.py --target 10.0.13.12 --port 2121
    python3 banner_grabber.py --target 10.0.13.11 --port 80 --http
    python3 banner_grabber.py --target 10.0.13.11 --ports 21,22,80,443,8080
================================================================================
"""

from __future__ import annotations 

import argparse 
import json 
import socket 
import ssl 
import sys 
from dataclasses import dataclass 
from datetime import datetime 
from typing import Dict ,List ,Optional 

# ==============================================================================
# CONSTANTE
# ==============================================================================

class Colors :
    RED ="\033[91m"
    GREEN ="\033[92m"
    YELLOW ="\033[93m"
    BLUE ="\033[94m"
    CYAN ="\033[96m"
    RESET ="\033[0m"
    BOLD ="\033[1m"


    # Probe for diferite protocols
PROTOCOL_PROBES ={
"generic":b"\r\n",
"http":b"HEAD / HTTP/1.1\r\nHost: target\r\nConnection: close\r\n\r\n",
"ftp":b"",# FTP send banner automat
"smtp":b"",# SMTP send banner automat
"ssh":b"",# SSH send banner automat
"mqtt":bytes ([0x10 ,0x0c ,0x00 ,0x04 ,0x4D ,0x51 ,0x54 ,0x54 ,0x04 ,0x00 ,0x00 ,0x3c ,0x00 ,0x00 ]),
}


# ==============================================================================
# DATA STRUCTURES
# ==============================================================================

@dataclass 
class BannerResult :
    """Resultul extragerii banner-ului."""
    host :str 
    port :int 
    protocol :str 
    banner :Optional [str ]
    headers :Dict [str ,str ]
    tls_info :Optional [Dict ]
    raw_response :bytes 
    success :bool 
    error :Optional [str ]=None 


    # ==============================================================================
    # FUNCTII DE GRABBING
    # ==============================================================================

def grab_generic_banner (
host :str ,
port :int ,
timeout :float =3.0 ,
probe :bytes =b"\r\n"
)->BannerResult :
    """
    Extrage banner-ul generic of at un service TCP.
    """
    result =BannerResult (
    host =host ,port =port ,protocol ="unknown",
    banner =None ,headers ={},tls_info =None ,
    raw_response =b"",success =False 
    )

    try :
        sock =socket .socket (socket .AF_INET ,socket .SOCK_STREAM )
        sock .settimeout (timeout )
        sock .connect ((host ,port ))

        # For unele services, banner-ul vine automat
        # For altele, sendm un probe
        if probe :
            sock .sendall (probe )

            # Citim responseul
        response =b""
        try :
            while len (response )<4096 :
                chunk =sock .recv (1024 )
                if not chunk :
                    break 
                response +=chunk 
                # If avem suficient for banner, ne oprim
                if b"\n"in response or len (response )>512 :
                    break 
        except socket .timeout :
            pass 

        sock .close ()

        result .raw_response =response 
        result .banner =response .decode ("utf-8",errors ="replace").strip ()
        result .success =True 

        # Detectam protocolul from banner
        banner_lower =result .banner .lower ()
        if "ssh"in banner_lower :
            result .protocol ="ssh"
        elif "ftp"in banner_lower or "220 "in banner_lower :
            result .protocol ="ftp"
        elif "smtp"in banner_lower or "220 "in banner_lower :
            result .protocol ="smtp"
        elif "http"in banner_lower :
            result .protocol ="http"
        elif "mqtt"in banner_lower or response .startswith (b"\x20"):
            result .protocol ="mqtt"

    except socket .timeout :
        result .error ="Connection timeout"
    except ConnectionRefusedError :
        result .error ="Connection refused"
    except Exception as e :
        result .error =str (e )

    return result 


def grab_http_banner (
host :str ,
port :int ,
timeout :float =3.0 ,
use_https :bool =False 
)->BannerResult :
    """
    Extrage information HTTP/HTTPS detaliate.
    """
    result =BannerResult (
    host =host ,port =port ,protocol ="https"if use_https else "http",
    banner =None ,headers ={},tls_info =None ,
    raw_response =b"",success =False 
    )

    try :
        sock =socket .socket (socket .AF_INET ,socket .SOCK_STREAM )
        sock .settimeout (timeout )
        sock .connect ((host ,port ))

        # Wrap in SSL if HTTPS
        if use_https :
            context =ssl .create_default_context ()
            context .check_hostname =False 
            context .verify_mode =ssl .CERT_NONE 
            sock =context .wrap_socket (sock ,server_hostname =host )

            # Extragem info TLS
            cert =sock .getpeercert (binary_form =True )
            result .tls_info ={
            "version":sock .version (),
            "cipher":sock .cipher (),
            }

            # Sendm request HTTP
        request =f"HEAD / HTTP/1.1\r\nHost: {host}\r\nConnection: close\r\nUser-Agent: S13-BannerGrabber/1.0\r\n\r\n"
        sock .sendall (request .encode ())

        # Citim responseul
        response =b""
        while True :
            chunk =sock .recv (4096 )
            if not chunk :
                break 
            response +=chunk 

        sock .close ()

        result .raw_response =response 
        response_str =response .decode ("utf-8",errors ="replace")

        # Parsam headerele
        lines =response_str .split ("\r\n")
        if lines :
            result .banner =lines [0 ]# Status line

            for line in lines [1 :]:
                if ": "in line :
                    key ,value =line .split (": ",1 )
                    result .headers [key .lower ()]=value 

        result .success =True 

    except ssl .SSLError as e :
        result .error =f"SSL error: {e}"
    except socket .timeout :
        result .error ="Connection timeout"
    except ConnectionRefusedError :
        result .error ="Connection refused"
    except Exception as e :
        result .error =str (e )

    return result 


def grab_banner (
host :str ,
port :int ,
timeout :float =3.0 ,
force_http :bool =False 
)->BannerResult :
    """
    Function wrapper which alege metoda potrivita of grabbing.
    """
    # Detectam protocolul bazat on port
    if force_http or port in [80 ,8080 ,8000 ,8888 ]:
        return grab_http_banner (host ,port ,timeout ,use_https =False )
    elif port in [443 ,8443 ]:
        return grab_http_banner (host ,port ,timeout ,use_https =True )
    else :
        return grab_generic_banner (host ,port ,timeout )


def print_result (result :BannerResult )->None :
    """Display resultul in format frumos."""
    print (f"\n{Colors.CYAN}{'─'*60}{Colors.RESET}")
    print (f"{Colors.BOLD}  {result.host}:{result.port} ({result.protocol}){Colors.RESET}")
    print (f"{Colors.CYAN}{'─'*60}{Colors.RESET}")

    if result .success :
        print (f"  {Colors.GREEN}[✓] Banner obtinut{Colors.RESET}")

        if result .banner :
            print (f"\n  {Colors.YELLOW}Banner:{Colors.RESET}")
            for line in result .banner .split ("\n")[:5 ]:
                print (f"    {line[:70]}")

        if result .headers :
            print (f"\n  {Colors.YELLOW}Headers relevante:{Colors.RESET}")
            for key in ["server","x-powered-by","content-type","www-authenticate"]:
                if key in result .headers :
                    print (f"    {key}: {result.headers[key]}")

        if result .tls_info :
            print (f"\n  {Colors.YELLOW}TLS Info:{Colors.RESET}")
            print (f"    Version: {result.tls_info.get('version')}")
            print (f"    Cipher: {result.tls_info.get('cipher')}")

    else :
        print (f"  {Colors.RED}[✗] Error: {result.error}{Colors.RESET}")


        # ==============================================================================
        # MAIN
        # ==============================================================================

def main ():
    parser =argparse .ArgumentParser (
    description ="Banner grabber for laboratory S13"
    )

    parser .add_argument ("--target",required =True ,help ="Adresa IP target")
    parser .add_argument ("--port",type =int ,help ="Port unic")
    parser .add_argument ("--ports",help ="Lista of ports (ex: 21,22,80,443)")
    parser .add_argument ("--http",action ="store_true",help ="Forteaza mod HTTP")
    parser .add_argument ("--timeout",type =float ,default =3.0 ,help ="Timeout (default: 3s)")
    parser .add_argument ("--json-out",help ="Export JSON")

    args =parser .parse_args ()

    if not args .port and not args .ports :
        print ("Specify --port or --ports")
        sys .exit (1 )

        # Banner
    print (f"\n{Colors.CYAN}{'='*60}")
    print ("  S13 - Banner Grabber")
    print (f"{'='*60}{Colors.RESET}")

    # Parsam portsle
    ports =[]
    if args .port :
        ports .append (args .port )
    if args .ports :
        ports .extend ([int (p .strip ())for p in args .ports .split (",")])

        # Executem grabbing
    results =[]
    for port in ports :
        result =grab_banner (args .target ,port ,args .timeout ,args .http )
        results .append (result )
        print_result (result )

        # Export JSON
    if args .json_out :
        data ={
        "scan_time":datetime .now ().isoformat (),
        "target":args .target ,
        "results":[
        {
        "port":r .port ,
        "protocol":r .protocol ,
        "banner":r .banner ,
        "headers":r .headers ,
        "success":r .success ,
        "error":r .error 
        }
        for r in results 
        ]
        }
        with open (args .json_out ,"w")as f :
            json .dump (data ,f ,indent =2 )
        print (f"\n{Colors.GREEN}[✓] Export: {args.json_out}{Colors.RESET}")

    print ()


if __name__ =="__main__":
    main ()
