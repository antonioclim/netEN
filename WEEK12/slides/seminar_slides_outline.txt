# =============================================================================
# SEMINAR PRESENTATION OUTLINE — Week 12
# Remote Procedure Call (RPC): JSON-RPC, XML-RPC, gRPC
# =============================================================================
# Format: Import to PowerPoint or reveal.js
# Estimate: 20 slides | ~50 minutes seminar + lab
# =============================================================================

## SECTION 0: OPENING
---
### Slide 1: Title
- **Seminar 12: Remote Procedure Call (RPC)**
- JSON-RPC • XML-RPC • gRPC
- Computer Networks — Practical Lab
- [Institution Logo] | [Date]

### Slide 2: Seminar Agenda
- RPC Concept and Motivation
- JSON-RPC 2.0: protocol and implementation
- XML-RPC: legacy protocol
- gRPC și Protocol Buffers: introduction
- Comparison and Protocol Selection
- Practical Exercises

### Slide 3: Practical Objectives
- What we will do:
  - Implement server and client JSON-RPC
  - Test XML-RPC with introspection
  - Compare protocol performance
  - Capturem și analizăm traficul RPC
- Competențe dezvoltate:
  - Proiectare API-uri distribuite
  - Debugging comunicare client-server
  - Alegerea tehnologiei potrivite

---
## SECTION 1: FUNDAMENTELE RPC
---
### Slide 4: Ce Este RPC?
- **Remote Procedure Call** = apel funcție pe server remote
- Abstracție: apelul pare local, execuția e la distanță
- Componentele:
  - **Client Stub**: serializează apelul, trimite, deserializează răspuns
  - **Server Stub**: deserializează, execute, serializează răspuns
  - **Transport**: TCP/HTTP/etc.
- [Diagramă: Client → Stub → Network → Stub → Server → Function]

### Slide 5: Fluxul unui Apel RPC
1. Client apelează `result = add(5, 3)`
2. Client Stub serializează: `{"method":"add","params":[5,3]}`
3. Trimite prin rețea către server
4. Server Stub deserializează, extrage metoda și parametrii
5. Server execute `add(5, 3)` → returnează `8`
6. Server Stub serializează: `{"result":8}`
7. Client Stub deserializează, returnează `8` către client

### Slide 6: Avantaje RPC
- **Transparență**: cod similar cu apeluri locale
- **Abstracție**: ascunde detaliile de rețea
- **Productivitate**: focus pe logică, nu pe protocol
- **Interoperabilitate**: client și server în limbaje diferite
- **Standardizare**: protocoale bine definite

---
## SECTION 2: JSON-RPC 2.0
---
### Slide 7: JSON-RPC — Introducere
- Protocol RPC lightweight peste JSON
- Specificație: jsonrpc.org (versiunea 2.0)
- Transport agnostic (de obicei HTTP POST)
- Human-readable, ușor de debugat
- Ideal pentru: API-uri web, microservicii

### Slide 8: Structura Request JSON-RPC
```json
{
  "jsonrpc": "2.0",
  "method": "add",
  "params": [5, 3],
  "id": 1
}
```
- `jsonrpc`: obligatoriu, versiunea "2.0"
- `method`: numele funcției
- `params`: array sau object (opțional)
- `id`: identificator cerere (null pentru notifications)

### Slide 9: Structura Response JSON-RPC
**Success:**
```json
{
  "jsonrpc": "2.0",
  "result": 8,
  "id": 1
}
```
**Error:**
```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32601,
    "message": "Method not found"
  },
  "id": 1
}
```

### Slide 10: Coduri de Error Standard
| Cod | Mesaj | Descriere |
|-----|-------|-----------|
| -32700 | Parse error | JSON invalid |
| -32600 | Invalid Request | Structură invalidă |
| -32601 | Method not found | Non-existent method |
| -32602 | Invalid params | Parametri invalizi |
| -32603 | Internal error | Error server internă |
| -32000 to -32099 | Server error | Erori definite de server |

### Slide 11: Batch Requests
- Trimite multiple cereri într-un singur request
- Reduce overhead conexiune
```json
[
  {"jsonrpc":"2.0","method":"add","params":[1,2],"id":1},
  {"jsonrpc":"2.0","method":"subtract","params":[10,3],"id":2},
  {"jsonrpc":"2.0","method":"multiply","params":[4,5],"id":3}
]
```
- Răspuns: array cu resultele (în orice ordine!)

### Slide 12: Notifications
- Cerere fără `id` = notification
- Serverul nu trimite răspuns
- Fire-and-forget pattern
```json
{"jsonrpc":"2.0","method":"log","params":["User logged in"]}
```
- Use case: logging, events, updates

---
## SECTION 3: XML-RPC
---
### Slide 13: XML-RPC — Introducere
- Predecesor JSON-RPC (1998)
- Format XML, mai verbose
- Transport: HTTP POST
- Introspection built-in
- Legacy, dar încă utilizat

### Slide 14: Structura XML-RPC
**Request:**
```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>add</methodName>
  <params>
    <param><value><int>5</int></value></param>
    <param><value><int>3</int></value></param>
  </params>
</methodCall>
```
**Response:**
```xml
<?xml version="1.0"?>
<methodResponse>
  <params>
    <param><value><int>8</int></value></param>
  </params>
</methodResponse>
```

### Slide 15: Tipuri de Date XML-RPC
| Tip | Tag | Exemplu |
|-----|-----|---------|
| Integer | `<int>` sau `<i4>` | `<int>42</int>` |
| Boolean | `<boolean>` | `<boolean>1</boolean>` |
| String | `<string>` | `<string>hello</string>` |
| Double | `<double>` | `<double>3.14</double>` |
| DateTime | `<dateTime.iso8601>` | `<dateTime.iso8601>20251231T12:00:00</dateTime.iso8601>` |
| Base64 | `<base64>` | `<base64>SGVsbG8=</base64>` |
| Array | `<array>` | `<array><data>...</data></array>` |
| Struct | `<struct>` | `<struct><member>...</member></struct>` |

### Slide 16: Introspection XML-RPC
- `system.listMethods()` — lista metodelor
- `system.methodSignature(name)` — semnătura
- `system.methodHelp(name)` — documentație
- Auto-discovery capabilități server

---
## SECTION 4: gRPC
---
### Slide 17: gRPC — Introducere
- Google RPC, open-source
- Protocol Buffers (protobuf) pentru serializare
- HTTP/2 transport (multiplexare, streaming)
- Performanță ridicată, overhead minim
- Code generation pentru multiple limbaje

### Slide 18: Protocol Buffers
```protobuf
syntax = "proto3";

service Calculator {
  rpc Add(AddRequest) returns (AddResponse);
  rpc Multiply(MultiplyRequest) returns (MultiplyResponse);
}

message AddRequest {
  int32 a = 1;
  int32 b = 2;
}

message AddResponse {
  int32 result = 1;
}
```
- Schema strongly-typed
- Versioning built-in
- Cod generat automat

### Slide 19: Tipuri de Apeluri gRPC
| Tip | Descriere | Use Case |
|-----|-----------|----------|
| Unary | Request → Response | CRUD, query |
| Server Streaming | Request → Stream Responses | Downloads, feeds |
| Client Streaming | Stream Requests → Response | Uploads, batching |
| Bidirectional | Stream ↔ Stream | Chat, real-time |

---
## SECTION 5: COMPARAȚIE
---
### Slide 20: JSON-RPC vs XML-RPC vs gRPC
| Aspect | JSON-RPC | XML-RPC | gRPC |
|--------|----------|---------|------|
| Format | JSON (text) | XML (text) | Protobuf (binary) |
| Overhead | ~50-100 bytes | ~200-500 bytes | ~20-50 bytes |
| Human-readable | ✓ Da | ✓ Da | ✗ Nu |
| Streaming | ✗ Nu | ✗ Nu | ✓ Da |
| Code-gen | Opțional | Opțional | Obligatoriu |
| Browser | ✓ Da | Limitată | Cu grpc-web |
| Performanță | Medie | Scăzută | Ridicată |
| Complexitate | Simplă | Simplă | Medie-Ridicată |

### Slide 21: Când Folosim Ce?
- **JSON-RPC**: API-uri web publice, prototipuri, integrări simple
- **XML-RPC**: Sisteme legacy, integrare cu cod vechi
- **gRPC**: Microservicii interne, latență critică, streaming

---
## SECTION 6: LABORATOR PRACTIC
---
### Slide 22: Structura Laboratorului
| Step | Activitate | Durată |
|------|------------|--------|
| 0 | Setup environment | 5 min |
| 1-3 | Server SMTP + capture | 15 min |
| 4-5 | JSON-RPC server/client | 15 min |
| 6 | XML-RPC + introspecție | 10 min |
| 7 | Benchmark comparativ | 10 min |
| 8 | Capture trafic RPC | 10 min |
| 9 | Exercises individuale | 25 min |

### Slide 23: Demo — Server JSON-RPC
```python
from http.server import BaseHTTPRequestHandler, HTTPServer
import json

class JSONRPCHandler(BaseHTTPRequestHandler):
    methods = {
        'add': lambda a, b: a + b,
        'subtract': lambda a, b: a - b,
        'multiply': lambda a, b: a * b,
    }
    
    def do_POST(self):
        # Parse request, execute method, return result
        ...
```
- Pornire: `python src/rpc/jsonrpc/jsonrpc_server.py`
- Test: `curl -X POST -d '{"jsonrpc":"2.0","method":"add","params":[5,3],"id":1}'`

### Slide 24: Demo — Client JSON-RPC
```python
import json
import urllib.request

def call_rpc(url, method, params, id=1):
    payload = {
        "jsonrpc": "2.0",
        "method": method,
        "params": params,
        "id": id
    }
    req = urllib.request.Request(url, 
        data=json.dumps(payload).encode(),
        headers={'Content-Type': 'application/json'})
    response = urllib.request.urlopen(req)
    return json.loads(response.read())
```

### Slide 25: Capture Trafic
- JSON-RPC:
  ```bash
  tshark -i lo -f "tcp port 8000" -Y "http" -T fields -e http.request.method -e http.file_data
  ```
- Filtre Wireshark:
  - `http.request.method == "POST"`
  - `json contains "jsonrpc"`
  - `xml contains "methodCall"`

---
## SECTION 7: ÎNCHEIERE
---
### Slide 26: Recapitulare
- RPC: apel funcție remote, transparent pentru client
- JSON-RPC: simplu, text, ideal web APIs
- XML-RPC: legacy, verbose, dar with introspection
- gRPC: performant, binary, streaming support
- Alegere: depinde de context (public/intern, performanță, limbaje)

### Slide 27: Exercises de Rezolvat
1. ★☆☆ Adaugă metodă `divide` cu gestionare error
2. ★★☆ Implementează batch request cu 5 operații
3. ★★☆ Compară overhead JSON vs XML (capture bytes)
4. ★★★ Implementează server XML-RPC minimal din scratch
5. ★★★★ Client gRPC Python folosind protobuf generat

### Slide 28: Întrebări?
- Resurse:
  - jsonrpc.org — Specificație JSON-RPC 2.0
  - grpc.io — Documentație gRPC
  - RFC 3529 — XML-RPC
- Contact: [email cadru didactic]
- Următorul seminar: Securitate în rețele

---
# =============================================================================
# Note pentru instructor:
# - Slide 23-24: demo live recomandat
# - Slide 25: pregătește terminale cu tshark pornit
# - Check că serverele pornesc înainte de seminar
# - Exercisesle 1-3 obligatorii, 4-5 bonus
# - Alocă 10 min la final pentru întrebări
# =============================================================================
# Revolvix&Hypotheticalandrei
# =============================================================================
