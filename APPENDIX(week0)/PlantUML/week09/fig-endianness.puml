@startuml fig-endianness
'A4 Landscape
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 11
skinparam shadowing false

title Byte Order (Endianness)\nNetwork vs Host byte order

rectangle "Value: 0x12345678" as value #F5F5F5

rectangle "Big-Endian (Network Order)" as big #E3F2FD {
    rectangle "Addr 0\n0x12" as b0 #BBDEFB
    rectangle "Addr 1\n0x34" as b1 #BBDEFB
    rectangle "Addr 2\n0x56" as b2 #BBDEFB
    rectangle "Addr 3\n0x78" as b3 #BBDEFB
    
    b0 -right[hidden]-> b1
    b1 -right[hidden]-> b2
    b2 -right[hidden]-> b3
}

rectangle "Little-Endian (x86 Host)" as little #E8F5E9 {
    rectangle "Addr 0\n0x78" as l0 #C8E6C9
    rectangle "Addr 1\n0x56" as l1 #C8E6C9
    rectangle "Addr 2\n0x34" as l2 #C8E6C9
    rectangle "Addr 3\n0x12" as l3 #C8E6C9
    
    l0 -right[hidden]-> l1
    l1 -right[hidden]-> l2
    l2 -right[hidden]-> l3
}

note bottom of big
    MSB first (Most Significant Byte)
    Used in network protocols
end note

note bottom of little
    LSB first (Least Significant Byte)
    Used by x86/x64 CPUs
end note

note as N1
    Python conversion:
    import socket
    
    # Host to Network (big-endian)
    network = socket.htons(port_16bit)
    network = socket.htonl(addr_32bit)
    
    # Network to Host (local)
    host = socket.ntohs(network_16bit)
    host = socket.ntohl(network_32bit)
    
    # struct module
    struct.pack('!I', value)  # ! = network
    struct.pack('<I', value)  # < = little
    struct.pack('>I', value)  # > = big
end note

